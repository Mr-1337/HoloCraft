--local ok, err = xpcall(function()
local mon = peripheral.find("monitor")
local ar = peripheral.find("arController")
local pd = peripheral.find("playerDetector")
local oldTerm = term.redirect(mon)     
mon.setTextScale(0.5)
mon.setCursorPos(1,1)
mon.clear() 
term.setCursorPos(1,1)
term.clear() 

local fov = math.rad(85)
local strokeSize = 2 --Default size of the lines drawn.
local colorDefault = 0xF6B26B  --Default color in hex.
local width = 530 --Adjust these to the resolution of your AR goggles. Guestimate screen width and height / 3. If the renders aren't centered it's because this is wrong.
local height = 300

local sf = 0.5 --scale factor to make the cube bigger
local n = 0.1  --Focal length
local f = 10 --how far camera sees
local r = width
local l = 0
local t = 0
local b = height

local aspectRatio = height/width
local S = aspectRatio / (math.tan(fov) * 0.5)

local locX = 0
local locY = 0
local locZ = 4

local rotX = math.rad(0)
local rotY = math.rad(0)
local rotZ = math.rad(0)

local offsetX = width*0.5
local offsetY = height*0.5

local cDot = 0.5*strokeSize

local function getData(name) 
    local pos = pd.getPlayerPos(name) 
    locX = pos.x
    print(pos.x)
    locY = pos.y
    print(pos.y)
    locZ = pos.z
    print(pos.z)

end

local function drawLine(x1,y1,x2,y2,col)
    local dx = x2 - x1
    local dy = y2 - y1
    for i = 1, 100 do
        local nextY = y1 + dy * (i / 100)
        local nextX = x1 + dx * (i / 100)
        if nextY > 0 + strokeSize and nextX > 0 + strokeSize then
            ar.fill(nextX - cDot, nextY - cDot, nextX + cDot, nextY + cDot, col)
        end
    end
end

local camlocation = {}
local rotationZ = {}
local rotationX = {}
local rotationY = {}
local projected = {}

local function printMatrix(m)
    print(#m.." x "..#m[1])
    print("------------")
    for i = 1, #m do
        for j = 1, #m[1] do
            mon.write(m[i][j].." ")
        end
        print()
    end
    print()
end

local function matmul(m1, m2)
    if #m1[1] ~= #m2 then
        error("Columns m1 must match rows m2",2)
        return nil
    end
    local result = {}
    for i = 1, #m1 do
        result[i] = {}
        for j = 1, #m2[1] do
            local sum = 0
            for k = 1, #m2 do
                sum = sum + (m1[i][k] * m2[k][j])
            end
        result[i][j] = sum
        end
    end
    return result
end

-- 3D DATA

local points = {
    {
        {-1},
        {-1},
        {1},
        {1}     },

    {   {-1},
        {1},
        {1},
        {1}     },

    {   {1},
        {1},
        {1},
        {1}     },

    {   {1},
        {-1},
        {1},
        {1}     },

    {   {-1},
        {-1},
        {-1},
        {1}     },

    {   {-1},
        {1},
        {-1},
        {1}     },

    {   {1},
        {1},
        {-1},
        {1}     },

    {   {1},
        {-1},
        {-1},
        {1}     }
}

local function connect(i,j,col)
    col = col or colorDefault
    drawLine(projected[i][1][1], projected[i][2][1], projected[j][1][1], projected[j][2][1],col)
end

local projection = {
    { aspectRatio / math.tan(fov * 0.5), 0, 0, 0 },
    { 0, 1 / (math.tan(fov * 0.5)), 0, 0 },
    { 0, 0, -f / (f - n), - f * n / (f - n) },
    { 0, 0, -1, 0 }
  }

local identityMatrix = {
    { 1, 0, 0, 0},
    { 0, 1, 0, 0},
    { 0, 0, 1, 0},
    { 0, 0, 0, 1}
}

local model = {
    { sf, 0, 0, 0},
    { 0, sf, 0, 3},
    { 0, 0, sf, 0},
    { 0, 0, 0, 1}
}

local offset = {
    { 1, 0, 0, width * 0.5},
    { 0, 1, 0, height * 0.5},
    { 0, 0, 1, 0},
    { 0, 0, 0, 1}
}


local function transformToScreen(data)
    local result = {}
    for i = 1, #data do
        result[i] = matmul(model, data[i])
        result[i] = matmul(rotationY, result[i])
        result[i] = matmul(rotationX, result[i])
        result[i] = matmul(rotationZ, result[i])
        result[i] = matmul(camlocation, result[i])
        result[i] = matmul(projection, result[i])
        local w = result[i][4][1]
        print(result[i][4][1])
        result[i][1][1] = result[i][1][1] / w
        result[i][2][1] = result[i][2][1] / w
        result[i][3][1] = result[i][3][1] / w
        result[i][4][1] = result[i][4][1] / w
        result[i][1][1] = (result[i][1][1] + 1.0) * 0.5 * width
        result[i][2][1] = (result[i][2][1] + 1.0) * 0.5 * height
        projected[i] = result[i]
    end
end

--== Main code ==
local count = 0

while true do
    count = count + 1
    mon.setCursorPos(1,1)
    getData("jig487")
    print(count)
    print("setting camlocation...")
    camlocation = {
        { 1, 0, 0, -locX },
        { 0, 1, 0, -locY },
        { 0, 0, 1, -locZ },
        { 0, 0, 0, 1}
    }
    print("setting rotZ...")
    rotationZ = {
        { math.cos(rotZ), -math.sin(rotZ), 0, 0 },
        { math.sin(rotZ), math.cos(rotZ), 0, 0 },
        { 0, 0, 1, 0 },
        { 0, 0, 0, 1}
    }
    print("setting rotY...")
    rotationY = {
        { math.cos(rotY), 0, math.sin(rotY), 0 },
        { 0, 1, 0, 0 },
        { -math.sin(rotY), 0, math.cos(rotY), 0 },
        { 0, 0, 0, 1}
    }
    print("setting rotX...")
    rotationX = {
        { 1, 0, 0, 0 },
        { 0, math.cos(rotX), -math.sin(rotX), 0 },
        { 0, math.sin(rotX), math.cos(rotX), 0 },
        { 0, 0, 0, 1}
    }
    transformToScreen(points)
    os.sleep(0.05)
    ar.clear()

    connect(1,2,0xB6D7A8)
    connect(2,3)
    connect(3,4)
    connect(4,1,0xB6D7A8)

    connect(5,6,0x9FC5E8)
    connect(6,7)
    connect(7,8)
    connect(8,5,0x9FC5E8)

    connect(1,5)
    connect(2,6)
    connect(3,7)
    connect(4,8)

    --rotY = rotY + 0.03
    --rotX = rotX + 0.03
    --rotZ = rotZ + 0.03
end

--end, debug.traceback) if not ok then printError(err) end
