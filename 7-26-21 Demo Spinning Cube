local ok, err = xpcall(function()
local mon = peripheral.find("monitor")
local ar = peripheral.find("arController")
local pd = peripheral.find("playerDetector")
local oldTerm = term.redirect(mon)     
mon.setTextScale(0.5)
mon.setCursorPos(1,1)
mon.clear() 
term.setCursorPos(1,1)
term.clear() 

--#### Customize these settings ####

local fov = math.rad(90)
local strokeSize = 1 --Default size of the lines drawn.
local colorDefault = 0xF6B26B  --Default color in hex.
local width = 530 --Adjust these to the resolution of your AR goggles. Guestimate screen width and height / 3. If the renders aren't centered it's because this is wrong.
local height = 300

--#### Variables ####

local n = 0.1  --Focal length
local f = 10 --how far camera sees
local r = width
local l = 0
local t = 0
local b = height
local aspectRatio = height/width
local S = aspectRatio / (math.tan(fov) * 0.5)

local cDot = 0.5*strokeSize
local frame = 0

local projected = {}

--#### Some Functions ####

local function printMatrix(m)
    print(#m.." x "..#m[1])
    print("------------")
    for i = 1, #m do
        for j = 1, #m[1] do
            mon.write(m[i][j].." ")
        end
        print()
    end
    print()
end

local function matmul(m1, m2)
    if #m1[1] ~= #m2 then
        error("Columns m1 must match rows m2",2)
        return nil
    end
    local result = {}
    for i = 1, #m1 do
        result[i] = {}
        for j = 1, #m2[1] do
            local sum = 0
            for k = 1, #m2 do
                sum = sum + (m1[i][k] * m2[k][j])
            end
        result[i][j] = sum
        end
    end
    return result
end

local projection = {
    { aspectRatio / math.tan(fov * 0.5), 0, 0, 0 },
    { 0, 1 / (math.tan(fov * 0.5)), 0, 0 },
    { 0, 0, -f / (f - n), - f * n / (f - n) },
    { 0, 0, -1, 0 } }

local identityMatrix = {
    { 1, 0, 0, 0},
    { 0, 1, 0, 0},
    { 0, 0, 1, 0},
    { 0, 0, 0, 1} }

local function makeModelMatrix(x,y,z)
    return {
        { x, 0, 0, 0},
        { 0, y, 0, 0},
        { 0, 0, z, 0},
        { 0, 0, 0, 1}, }
end

local function makeTranslationMatrix(x,y,z)
    return {
        { 1, 0, 0, x },
        { 0, 1, 0, -y },
        { 0, 0, 1, -z },
        { 0, 0, 0, 1} }
end

local function makeRotationMatrix(x,y,z)
    x = math.rad(x)
    y = math.rad(y)
    z = math.rad(z)--[[
    local rotX = {
        { 1, 0,            0,           0},
        { 0, math.cos(x), -math.sin(x), 0},
        { 0, math.sin(x),  math.cos(x), 0},
        { 0, 0,            0,           1}, }
    local rotY = {
        {  math.cos(y), 0, math.sin(y), 0 },
        {  0,           1, 0,           0 },
        { -math.sin(y), 0, math.cos(y), 0 },
        {  0,           0, 0,           1 }, }
    local rotZ = {
        { math.cos(z), -math.sin(z), 0, 0},
        { math.sin(z),  math.cos(z), 0, 0},
        { 0,            0,           1, 0},
        { 0,            0,           0, 1}, }
    return matmul(rotZ, matmul(rotX, rotY))   ]]
    return {
        {   math.cos(y) * math.cos(z),                                                -math.cos(y) * math.sin(z),                                               math.sin(y),               0 },
        {  (math.sin(x) * math.sin(y) * math.cos(z)) + (math.cos(x) * math.sin(z)), (-math.sin(x) * math.sin(y) * math.sin(z)) + (math.cos(x) * math.cos(z)),  -math.sin(x) * math.cos(y), 0},
        { (-math.cos(x) * math.sin(y) * math.cos(z)) + (math.sin(x) * math.sin(z)),   (math.cos(x) * math.sin(y) * math.sin(z)) + (math.sin(x) * math.cos(z)),  math.cos(x) * math.cos(y), 0},
        { 0, 0, 0, 1}, }
    --return identityMatrix
end

local objectList = {
    cube1 = {
        {"cube"},
        {1, 1, 1},--Scale
        {15, 45, 0},--Rotation
        {0, 0, 3},--Translation
        {0x3498DB},--Color
    },
}

    --[[local function getData(name) 
    local pos = pd.getPlayerPos(name) 
    locX = pos.x
    locY = pos.y
    locZ = pos.z
end  ]]

local function drawLine(x1,y1,x2,y2,id)
    local dx = x2 - x1
    local dy = y2 - y1
    for i = 1, 100 do
        local nextY = y1 + dy * (i / 100)
        local nextX = x1 + dx * (i / 100)
        if nextY > 0 + strokeSize and nextX > 0 + strokeSize then
            ar.fill(nextX - cDot, nextY - cDot, nextX + cDot, nextY + cDot, objectList[id][5][1])
        end
    end
end

-- #### 3D Base Models ####

local cubeTriangles = {
    {--South 2
        {   {0}, {0}, {1}, {1}, },
        {   {0}, {1}, {1}, {1}, },
        {   {1}, {1}, {1}, {1}, }, },
    {--South 2
        {   {0}, {0}, {1}, {1}, },
        {   {1}, {1}, {1}, {1}, },
        {   {1}, {0}, {1}, {1}, }, },
    {--East 1
        {   {1}, {0}, {1}, {1}, },
        {   {1}, {1}, {1}, {1}, },
        {   {1}, {1}, {0}, {1}, }, },
    {--East 2
        {   {1}, {0}, {1}, {1}, },
        {   {1}, {1}, {0}, {1}, },
        {   {1}, {0}, {0}, {1}, }, },
    {--North 1
        {   {1}, {0}, {0}, {1}, },
        {   {1}, {1}, {0}, {1}, },
        {   {0}, {1}, {0}, {1}, }, },
    {--North 2
        {   {1}, {0}, {0}, {1}, },
        {   {0}, {1}, {0}, {1}, },
        {   {0}, {0}, {0}, {1}, }, },
    {--West 1
        {   {0}, {0}, {0}, {1}, },
        {   {0}, {1}, {0}, {1}, },
        {   {0}, {1}, {1}, {1}, }, },
    {--West 2
        {   {0}, {0}, {0}, {1}, },
        {   {0}, {1}, {1}, {1}, },
        {   {0}, {0}, {1}, {1}, }, },
    {--Top 1
        {   {0}, {1}, {1}, {1}, },
        {   {0}, {1}, {0}, {1}, },
        {   {1}, {1}, {0}, {1}, }, },
    {--Top 2
        {   {0}, {1}, {1}, {1}, },
        {   {1}, {1}, {0}, {1}, },
        {   {1}, {1}, {1}, {1}, }, },
    {--Bottom 1
        {   {0}, {0}, {0}, {1}, },
        {   {0}, {0}, {1}, {1}, },
        {   {1}, {0}, {1}, {1}, }, },
    {--Bottom 2
        {   {0}, {0}, {0}, {1}, },
        {   {1}, {0}, {1}, {1}, },
        {   {1}, {0}, {0}, {1}, }, },
}

-- #### Drawing Stuff ####



local function transformToScreen(id,targetModelBase)
    local result = {}
    projected[id] = {}
    local modelMat = makeModelMatrix(objectList[id][2][1],objectList[id][2][2],objectList[id][2][3])
    local rotMat = makeRotationMatrix(objectList[id][3][1],objectList[id][3][2],objectList[id][3][3])
    local transMat = makeTranslationMatrix(objectList[id][4][1],objectList[id][4][2],objectList[id][4][3])
    for i = 1, #targetModelBase do
        result[i] = {}
        projected[id][i] = {}
        for j = 1, #targetModelBase[i] do
            result[i][j] = matmul(projection, matmul(transMat, matmul(rotMat, matmul(modelMat, targetModelBase[i][j]))))
            local w = result[i][j][4][1]
            for k = 1, 4 do
                result[i][j][k][1] = result[i][j][k][1] / w
            end
            result[i][j][1][1] = (result[i][j][1][1] + 1.0) * 0.5 * width
            result[i][j][2][1] = (result[i][j][2][1] + 1.0) * 0.5 * height
            projected[id][i][j] = result[i][j]
        end
    end
end

local function connectTriangles(id)
    for i = 1, #projected[id] do
        drawLine(projected[id][i][1][1][1], projected[id][i][1][2][1], projected[id][i][2][1][1], projected[id][i][2][2][1], id)
        drawLine(projected[id][i][2][1][1], projected[id][i][2][2][1], projected[id][i][3][1][1], projected[id][i][3][2][1], id)
        drawLine(projected[id][i][3][1][1], projected[id][i][3][2][1], projected[id][i][1][1][1], projected[id][i][1][2][1], id)
    end
end

--#### API Stuff ####

local function makeCube(id) --Make a new cube with an id
    objectList[id] = {
        {"cube"},
        {1, 1, 1},--Scale
        {0, 0, 0},--Rotation
        {0, 0, 0},--Translation
        {colorDefault}--Color
    }
end

local function loadModel(id) --Calculate the position for the target model on the screen
    if objectList[id][1][1] == "cube" then
        transformToScreen(id,cubeTriangles)
    end
end

local function draw(id) --draw the cube to the screen
    connectTriangles(id)
end

local function setScale(id,x,y,z) --Set the initial scale of an object. 1 = x val, 2 = y val, 3 = z val
    x,y,z = x,y,z or 1,1,1 
    objectList[id][2][1] = x
    objectList[id][2][2] = y
    objectList[id][2][3] = z
end

local function setRot(id,x,y,z) --Set the initial rotation of an object. 1 = x val, 2 = y val, 3 = z val
    x,y,z = x,y,z or 0,0,0 
    objectList[id][3][1] = x
    objectList[id][3][2] = y
    objectList[id][3][3] = z
end

local function setLoc(id,x,y,z) --Set the initial location of an object. 1 = x val, 2 = y val, 3 = z val
    x,y,z = x,y,z or 0,0,0 
    objectList[id][4][1] = x
    objectList[id][4][2] = y
    objectList[id][4][3] = z
end

local function setColor(id,color) --Set the initial color of an object. 1 = x val, 2 = y val, 3 = z val
    objectList[id][5][1] = color
end

local function incrementScale(id,j,k) --Increment the scale of an object. 1 = x val, 2 = y val, 3 = z val,  k is by how much
    objectList[id][2][j] = objectList[id][2][j] + k
end

local function incrementRot(id,j,k)  --Increment the rotation of an object. 1 = x val, 2 = y val, 3 = z val,  k is by how much
    objectList[id][3][j] = objectList[id][3][j] + k
end

local function incrementLoc(id,j,k)  --Increment the location of an object. 1 = x val, 2 = y val, 3 = z val,  k is by how much
    objectList[id][4][j] = objectList[id][4][j] + k
end

--== Define objects to draw ==

--== Draw loop ==

while true do
    frame = frame + 1
    mon.setCursorPos(1,1)
    print(frame)
    --getData("jig487")

    incrementRot("cube1",2,3)
    incrementRot("cube1",3,3)
    incrementRot("cube1",1,3)
    loadModel("cube1")

    os.sleep(0.1)
    ar.clear()

    draw("cube1")
    --incrementRot("cube1",3,3)
end

end, debug.traceback) if not ok then printError(err) end
